#include <stdio.h>
#include <stdlib.h>
#include "../trees/trees.h"
#include "treeKEM.h"
#include "../../skeleton.h"
#include "../../crypto/crypto.h"
#include "../../utils.h"

// TODO: free crypto material
void blank_dir_path(struct Node *node) {
  while (node != NULL) {
    ((struct NodeData *) node->data)->blank = 1;
    node = node->parent;
  }
}

// TODO: free crypto material
// TODO: just do in tree files??
void blank_skel(struct SkeletonNode *skeleton) {
  if (!skeleton->special) {
    ((struct NodeData *) skeleton->node->data)->blank = 1;
  }
  if (skeleton->children != NULL) {
    int i;
    for (i = 0; i < skeleton->node->num_children; i++) {
      if (*(skeleton->children + i) != NULL)
	blank_skel(*(skeleton->children + i));
    }
  }
}

/*
 * add id to the group
 */
struct Node *treeKEM_add(struct treeKEM *treeKEM, int id) {
  struct AddRet add_ret = { NULL, NULL };
  if (treeKEM->tree_type == 0)
    add_ret = lbbt_add(treeKEM->tree, id);
  else if (treeKEM->tree_type == 1)
    add_ret = btree_add(treeKEM->tree, id); // TODO: bring back gen funcs!
  else
    add_ret = LLRBTree_add(treeKEM->tree, id);
    //add_ret = gen_tree_add(treeKEM->tree, data, &btree_add);
  blank_skel(add_ret.skeleton);
  addAfter(treeKEM->users, treeKEM->users->tail, (void *) add_ret.added);
  return add_ret.added;
}

/*
 * update the id that was the user-th added id of the group
 */
int treeKEM_update(struct treeKEM *treeKEM, int user) { 
  struct Node *user_node = (struct Node *) findNode(treeKEM->users, user)->data;
  blank_dir_path(user_node->parent);
  return ((struct NodeData *) user_node)->id;
}

/*
 * remove the id that was the user-th added id of the group
 */
int treeKEM_rem(struct treeKEM *treeKEM, int user) {
  struct RemRet ret = { -1, NULL };
  struct Node *user_node = (struct Node *) findAndRemoveNode(treeKEM->users, user);
  if (treeKEM->tree_type == 0)
    ret = lbbt_rem(treeKEM->tree, user_node);
  else if (treeKEM->tree_type == 1)
    ret = btree_rem(treeKEM->tree, user_node);
  else
    ret = LLRBTree_rem(treeKEM->tree, user_node);
    //ret = gen_tree_rem(treeKEM->tree, user, &btree_rem);
  blank_skel(ret.skeleton);
  return ret.id;
}

void get_resolution(struct List *resolution_nodes, struct Node *node, int added) {
  struct NodeData *data = (struct NodeData *) node->data;
  if (!data->blank) {
    if (!added)
      addFront(resolution_nodes, node);    
    struct ListNode *curr = data->tk_unmerged->head;
    while (curr != NULL) {
      addFront(resolution_nodes, curr->data);
      get_resolution(resolution_nodes, curr->data, 1);
      curr = curr->next;
    }
  } else {
    int i;
    for (i = 0; i < node->num_children; i++)
      get_resolution(resolution_nodes, *(node->children + i), 0);
  }
}

/*
 * create ciphertexts for a node in a skeleton generated by an op, skeleton_node
 */
int ct_gen(struct treeKEM *treeKEM, struct SkeletonNode *skeleton_node, void *seed, void *generator) {
  if (skeleton_node->children_color != NULL) {
    struct List **ct_lists = NULL;
    if (treeKEM->crypto) {
      ct_lists = malloc_check(sizeof(struct List *) * skeleton_node->node->num_children);
      skeleton_node->ciphertext_lists = ct_lists;
    }
    int i;
    for (i = 0; i < skeleton_node->node->num_children; i++) {
      struct List *ct_list = NULL;
      if (*(skeleton_node->children_color + i) == 1) {
	struct List resolution_nodes;
	initList(&resolution_nodes);
	get_resolution(&resolution_nodes, skeleton_node->node, 0);

	(*(treeKEM->counts + 1)) += resolution_nodes.len;
	if (treeKEM->crypto) {
	  struct ListNode *res_curr = resolution_nodes.head;
	  while (res_curr != NULL) {
	    struct Ciphertext *ct_struct = NULL;
	    ct_struct = malloc_check(sizeof(struct Ciphertext));
	    void *ct = malloc_check(treeKEM->seed_size);
	    struct NodeData *data = (struct NodeData *) ((struct Node *) res_curr->data)->data;
	    ct_struct->child_id = data->id;
	    enc(generator, data->key, data->seed, seed, ct, treeKEM->seed_size); //TODO: do for TK
	    ct_struct->ct = ct;
	    addFront(ct_list, ct_struct);
	    
	    res_curr = res_curr->next;
	  }
	  *ct_lists++ = ct_list;
	}
      } else if (treeKEM->crypto) 
	*ct_lists++ = ct_list;
    }
  } else if (((struct LBBT *) treeKEM->tree)->root == skeleton_node->node) {
    (*(treeKEM->counts + 1))++;
    if (treeKEM->crypto) {
      struct List **ct_lists = malloc_check(sizeof(struct List *));
      struct List *ct_list = malloc_check(sizeof(struct List));
      *ct_lists = ct_list;
      struct Ciphertext *ct_struct = malloc_check(sizeof(struct Ciphertext));
      void *ct = malloc_check(treeKEM->seed_size);
      struct NodeData *root_data = (struct NodeData *) skeleton_node->node->data;
      ct_struct->child_id = root_data->id;
      enc(generator, root_data->key, root_data->seed, seed, ct, treeKEM->seed_size);
      ct_struct->ct = ct;
      addFront(ct_list, ct_struct);
      skeleton_node->ciphertext_lists = ct_lists;
    }
  }
  return 0;
}

/*
 * recursively generates the secrets on the direct path of a committer and the corresponding ciphertexts
 */
void *secret_gen(struct treeKEM *treeKEM, struct SkeletonNode *skeleton, void *sampler, void *generator) {
  void *prev_seed = NULL;
  void *next_seed = NULL;
  if (skeleton->children_color != NULL) {
    int i;
    for (i = 0; i < skeleton->node->num_children; i++) {
      if (*(skeleton->children_color + i) == 0)
	prev_seed = secret_gen(treeKEM, *(skeleton->children + i), sampler, generator);
    }
  } else if (treeKEM->crypto) { // leaf node
    prev_seed = malloc_check(treeKEM->seed_size);
    sample(sampler, prev_seed);
  }

  ct_gen(treeKEM, skeleton, prev_seed, generator);
  (*(treeKEM->counts))++;  
  struct NodeData *data = (struct NodeData *) skeleton->node->data;  
  if (treeKEM->crypto) {
    void *seed = NULL, *key = NULL, *out = NULL;
    alloc_prg_out(&out, &seed, &key, &next_seed, treeKEM->prg_out_size, treeKEM->seed_size); //TODO: change to TK stuff
    prg(generator, prev_seed, out);
    split(out, seed, key, next_seed, treeKEM->seed_size);
    free(out);
    //printf("seed: %s\n", (char *) prev_seed);
    
    if (data->key != NULL)
      free(data->key);
      if (data->seed != NULL)
      free(data->seed);
    data->key = key;
    data->seed = seed;
  }

  if (skeleton->node->num_leaves > 1 || skeleton->parent == NULL)
    free(prev_seed); // need to free here if not oob_seed
  
  return next_seed;
}

/*
 * creates skeleton for commit consisting of direct path with prgs along path cts to copath resolutions
 */
struct SkeletonNode *gen_commit_skel(struct Node *node, struct Node *child, struct SkeletonNode *child_skel) {
  if (node != NULL) {
    struct NodeData *data = (struct NodeData *) node->data;
    if (node->children != NULL)
      removeAllNodes(data->tk_unmerged);
    data->blank = 0;
    
    struct SkeletonNode *skeleton = malloc_check(sizeof(struct SkeletonNode));
    skeleton->node_id = data->id;
    skeleton->node = node;
    skeleton->ciphertext_lists = NULL;

    int i, child_pos = 0;
    if (child != NULL) {
      int *children_color = malloc_check(sizeof(int) * node->num_children);
      for (i = 0; i < node->num_children; i++) {
	if (child == *(node->children + i)) {
	  child_pos = i;
	  *(children_color + i) = 0;
	} else
	  *(children_color + i) = 1;
      }
      skeleton->children_color = children_color;      
    } else
      skeleton->children_color = NULL;
    
    if (child_skel != NULL) {
      struct SkeletonNode **skel_children = malloc_check(sizeof(struct skeletonNode *) * node->num_children);
      for (i = 0; i < node->num_children; i++)
	*(skel_children + i) = NULL;
      *(skel_children + child_pos) = child_skel;
      skeleton->children = skel_children;
      child_skel->parent = skeleton;      
    } else
      skeleton->children = NULL;

    return gen_commit_skel(node->parent, node, skeleton);
  }
  child_skel->parent = NULL;
  return child_skel;
}

struct SkeletonNode *treeKEM_commit(struct treeKEM *treeKEM, int committer, void *sampler, void *generator) {
  struct Node *commit_user = (struct Node *) findNode(treeKEM->users, committer)->data;
  struct SkeletonNode *commit_skel = gen_commit_skel(commit_user, NULL, NULL);
  secret_gen(treeKEM, commit_skel, sampler, generator);
  return commit_skel;
}

/*
 * initialize group with n users for tree type specified by tree_type
 */
struct treeKEMInitRet treeKEM_init(int n, int crypto, int *tree_flags, int tree_type, void *sampler, void *generator) {
  struct treeKEMInitRet ret = { NULL, NULL };
  struct List *users = malloc_check(sizeof(struct List));
  initList(users);
  
  int ids[n];
  int i;
  for (i = 0; i < n; i++) {
    ids[i] = i;
  }

  int *counts = malloc_check(sizeof(int) * 2);
  *counts++ = 0;
  *counts-- = 0;

  void *tree = NULL;
  struct InitRet tree_ret = { NULL, NULL };
  if (tree_type == 0) {
    tree_ret = lbbt_init(ids, n, *tree_flags, *(tree_flags + 1), users);
    tree = tree_ret.tree;
  } else if (tree_type == 1) {
    tree_ret = btree_init(ids, n, *tree_flags, *(tree_flags + 1), users);
    tree = tree_ret.tree;
  } else if (tree_type == 2) {
    tree_ret = LLRBTree_init(ids, n, *tree_flags, *(tree_flags + 1), users);
    tree = tree_ret.tree;
  }
  
  size_t prg_out_size = 0, seed_size = 0;
  if (crypto) {
    get_prg_out_size(generator, &prg_out_size);
    get_seed_size(generator, &seed_size);
  }

  struct treeKEM *treeKEM_ptr = malloc_check(sizeof(struct treeKEM));
  struct treeKEM treeKEM = { users, tree, counts, tree_type, crypto, prg_out_size, seed_size };
  *treeKEM_ptr = treeKEM;

  struct SkeletonNode *commit_skel = gen_commit_skel(users->head->data, NULL, NULL);
  secret_gen(treeKEM_ptr, commit_skel, sampler, generator);

  ret.treeKEM = treeKEM_ptr;
  ret.skeleton = commit_skel;

  return ret;
}

void free_treeKEM(struct treeKEM *treeKEM) {
  free_tree(((struct LBBT *) treeKEM->tree)->root);
  removeAllNodes(((struct LBBT *) treeKEM->tree)->blanks);
  free(((struct LBBT *) treeKEM->tree)->blanks);
  free(treeKEM->tree);
  removeAllNodes(treeKEM->users);
  free(treeKEM->users);
  free(treeKEM->counts);
  free(treeKEM);
}
